#!/usr/bin/env ruby
#
# Author:: Andrew Pennebaker
#
# Copyright:: Copyright 2012 Andrew Pennebaker
#
# == Synopsis
#
# specs - Get system specs easily
#
# == Usage
#
# specs [aspects]
#
# Example:
#
# specs ruby os hardware
#
# By default, aspects are os and hardware.
#
# --help, -h:
#    show usage info for specs
#
# --version, -v:
#    print specs' own version

require "rubygems"
require "extlib"
require "getoptlong"
require "rdoc/usage"

SPECS_VERSION = "0.1"

# Get the operating system reliably, even in JRuby
module Os
    def Os.raw
        Config::CONFIG["host_os"]
    end

    def Os.windows?
        Os.raw =~ /cygwin|mswin|mingw|bccwin|wince|emx/
    end

    def Os.mac?
        Os.raw =~ /darwin/
    end

    def Os.unix?
        not Os.windows?
    end

    def Os.linux?
        Os.unix? and not Os.mac?
    end

    def Os.haiku?
        Os.raw =~ /haiku/
    end

    def Os.sep
        # Windows / MS DOS
        if Os.windows?
            " & "
        # Assume Unix variant.
        else
            " && "
        end
    end

    def Os.command
        if Os.windows?
            "ver"
        elsif Os.mac?
            "system_profiler SPSoftwareDataType | grep System"
        else
            "uname -a"
        end
    end
end

BUILTINS = ["os"]

# For a given spec, return the command line instruction(s)
# that will get the spec's version information.
def command(spec)
    # For builtin specs,
    # 1. Locate module's name via CamelCase.
    # 2. Access module.command.
    if BUILTINS.include?(spec)
        mod_name = spec.camel_case
        mod = Kernel.const_get(mod_name)
        mod.command
    elsif !BUILTINS.include?(spec)
        require_path = "commands/#{spec}"

        # For nonstandard specs,
        # 1. Check that a Ruby module exists in the commands subdirectory.
        # 2. Load the module.
        # 3. Locate module's name via CamelCase.
        # 4. Access module.command.
        if File.exist?("#{require_path}.rb")
            require require_path

            mod_name = spec.camel_case
            mod = Kernel.const_get(mod_name)
            mod.command
        # If unknown spec, assume:
        # * Spec name = binary name.
        # * Binary is in PATH.
        # * Binary CLI options use --version.
        else
            "#{spec} --version"
        end
    end
end

# Print a command line instruction and its output,
# Emulating a user manually entering the instruction.
def run(cmd)
    puts cmd

    output = `#{cmd}`
    puts "#{output}\n"
end

def usage
    RDoc::usage("Usage")
    exit
end

def print_specs_own_version
    puts "specs #{SPECS_VERSION}"
    exit
end

def main
    opts = GetoptLong.new(
        ["--help", "-h", GetoptLong::NO_ARGUMENT],
        ["--version", "-v", GetoptLong::NO_ARGUMENT]
    )

    begin
        opts.each { |option, value|
            case option
            when "--help"
                usage
            when "--version"
                print_specs_own_version
            end
        }
    rescue GetoptLong::InvalidOption
        usage
    end

    # Default specs
    specs = ["os", "hardware"]
    if !ARGV.empty?
        specs = ARGV
    end

    puts "Specs:\n\n"

    specs.each { |spec|
        cmds = command(spec)

        # Module returns a single command string.
        if cmds.instance_of?(String)
            run(cmds)
        # Assume module returns an array of command strings.
        else
            cmds.each { |cmd| run(cmd) }
        end
    }
end

# Allow specs to be imported by other Ruby code.
# If run alone, call the main function.
if __FILE__==$0
	begin
		main
	rescue Interrupt => e
		nil
	end
end